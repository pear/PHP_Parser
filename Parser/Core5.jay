%{
?><?php
//
// +----------------------------------------------------------------------+
// | PHP_Parser                                                           |
// +----------------------------------------------------------------------+
// | Copyright (c) 1997-2004 The PHP Group                                |
// +----------------------------------------------------------------------+
// | This source file is subject to version 3.0 of the PHP license,       |
// | that is bundled with this package in the file LICENSE, and is        |
// | available through the world-wide-web at the following url:           |
// | http://www.php.net/license/3_0.txt.                                  |
// | If you did not receive a copy of the PHP license and are unable to   |
// | obtain it through the world-wide-web, please send a note to          |
// | license@php.net so we can mail you a copy immediately.               |
// +----------------------------------------------------------------------+
// | Authors: Greg Beaver <cellog@php.net>                                |
// +----------------------------------------------------------------------+
//
// $Id$
//
/*
   +----------------------------------------------------------------------+
   | Based on the Zend Engine                                             |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2002 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   | native PHP version:  Greg Beaver <cellog@php.net>                    |
   +----------------------------------------------------------------------+
   Last synchronized with zend_language_parser.y on Feb 26, 2004
*/

define('PHP_PARSER_STRUCTURE_ERROR_PARSE', 1);
require_once 'PHP/Parser/MsgServer.php';
//
// This does nothing on it's own - refer to PHP_Parser
// It's purely the code for the Parser, generated by phpJay
//
 

class PHP_Parser_Structure {

    /**
     * Options, used to control how the parser collects
     * and distributes the data it finds.
     *
     * Currently, options are grouped into two categories:
     * - containers for data
     * - publishing of data
     *
     * Default action is to return arrays of parsed data
     * for use by other applications.  The first set of
     * options, container options, provide a means to
     * tell the parser to encapsulate data in objects
     * instead of in arrays.  The option tells the parser which
     * class to instantiate for each documentable element.  The
     * default value of false will prompt the usage of arrays
     * instead.
     *
     * The second set of options provide for intermediary
     * publishing of data while parsing, to allow other
     * classes to hook into functionality if they desire
     * @var array
     * @access private
     */
    var $_options = array();
    
    /**
     * @var PHP_Parser_MsgServer
     */
    var $_server;
    
    /**
     * Unique MsgServer id assigned upon registerListener
     * @var integer
     */
    var $_serverId;
    
    /**
     * @var boolean
     */
    var $_get_class = false;
    
    /**
     * @access private
     */
    var $_grabDefine = false;
    /**
     * @access private
     */
    var $_inGlobal = false;
    /**
     * @access private
     */
    var $_lastConst = false;
    /**
     * @var PEAR_ErrorStack
     */
    var $_errors;

    function PHP_Parser_Structure($options = array())
    {
        $this->_errors = &PEAR_ErrorStack::singleton('PHP_Parser_Structure');
        $this->_server = &PHP_Parser_MsgServer::singleton();
        $this->_serverId = $this->_server->registerListener($this);
        $this->_options['classContainer'] =
        $this->_options['interfaceContainer'] =
        $this->_options['includeContainer'] =
        $this->_options['functionContainer'] =
        $this->_options['globalContainer'] =
        $this->_options['varContainer'] =
        $this->_options['constContainer'] =
        $this->_options['classConstContainer'] =
        $this->_options['methodContainer'] =
        $this->_options['publisher'] =
        $this->_options['publishMethod'] =
        $this->_options['publishClasses'] =
        $this->_options['publishClassMessage'] =
        $this->_options['publishInterfaces'] =
        $this->_options['publishInterfaceMessage'] =
        $this->_options['publishIncludes'] =
        $this->_options['publishIncludeMessage'] =
        $this->_options['publishFunctions'] =
        $this->_options['publishFunctionMessage'] =
        $this->_options['publishGlobals'] =
        $this->_options['publishGlobalMessage'] =
        $this->_options['publishVars'] =
        $this->_options['publishVarMessage'] =
        $this->_options['publishClassConsts'] =
        $this->_options['publishClassConstMessage'] =
        $this->_options['publishMethods'] =
        $this->_options['publishMethodMessage'] =
        $this->_options['publishConsts'] =
        $this->_options['publishConstMessage'] =
        false;
        $this->_options = array_merge($this->_options, $options);
        if (!class_exists($this->_options['classContainer'])) {
            $this->_options['classContainer'] = false;
        }
        if (!class_exists($this->_options['interfaceContainer'])) {
            $this->_options['interfaceContainer'] = false;
        }
        if (!class_exists($this->_options['includeContainer'])) {
            $this->_options['includeContainer'] = false;
        }
        if (!class_exists($this->_options['functionContainer'])) {
            $this->_options['functionContainer'] = false;
        }
        if (!class_exists($this->_options['globalContainer'])) {
            $this->_options['globalContainer'] = false;
        }
        if (!class_exists($this->_options['varContainer'])) {
            $this->_options['varContainer'] = false;
        }
        if (!class_exists($this->_options['constContainer'])) {
            $this->_options['constContainer'] = false;
        }
        if (!class_exists($this->_options['classConstContainer'])) {
            $this->_options['classConstContainer'] = false;
        }
        if (!class_exists($this->_options['methodContainer'])) {
            $this->_options['methodContainer'] = false;
        }
        if (!is_object($this->_options['publisher'])) {
            $this->_options['publisher'] = &PHP_Parser_MsgServer::singleton();
        } else {
            if (!method_exists($this->_options['publisher'], $this->_options['publishMethod'])) {
                $this->_options['publishMethod'] = false;
                if (!method_exists($this->_options['publisher'], 'sendMessage')) {
                    $this->_options['publisher'] = false;
                } else {
                    $this->_options['publishMethod'] = 'sendMessage';
                }
            }
        }
    }

    /**
     * (syntax) error message.
     * Can be overwritten to control message format.
     * @param message text to be displayed.
     * @param expected vector of acceptable tokens, if available.
     */
    function raiseError ($message, $code, $params)
    {     
        if (isset($params['expected'])) {
            $p = $params['expected'];
            $m = "$message, expecting ";
            if (count($p) - 1) {
                $last = array_pop($p);
                array_push($p, 'or ' . $last);
            }
            $m .= implode(', ', $p);
        } else {
            $m = $message;
        }
        return PEAR_ErrorStack::staticPush('PHP_Parser_Structure',
            PHP_PARSER_STRUCTURE_ERROR_PARSE,
            'error', $params,
            $m);  
    }

    /**
     * array of classes => array(methods => ...., vars => ....)
     *
     * @var array
     * @access public 
     */

    var $classes = array();

    /**
     * array of interfaces => array(methods => ...., vars => ....)
     *
     * @var array
     * @access public 
     */

    var $interfaces = array();
    /**
     * array of includes
     *
     * @var array
     * @access public 
     */
    var $includes = array();

    /**
     * array of functions
     *
     * @var array
     * @access public 
     */
    var $functions = array();

    /**
     * array of global variables
     *
     * @var array
     * @access public 
     */
    var $globals = array();

    /**
     * array of super-global variables used in
     * non-procedural global code (page-level parameters)
     *
     * @var array
     * @access public 
     */
    var $filesuperglobals = array();

    /**
     * array of variables referenced as $this->var in a class method
     *
     * @var array
     * @access public 
     */
    var $referencedVars = array();
    
    /**
     * array of methods referenced as $this->method() in a class method
     *
     * @var array
     * @access public 
     */
    var $referencedMethods = array();
    
    /**
     * File Summary documentation (page-level DocBlock in phpDocumentor)
     * @var string
     * @access public
     */
    var $documentation;

    /**
     * array of global constants
     *
     * @var array
     * @access public 
     */
    var $constants = array();

    /**
     * global variable name of parser arrays
     * should match the build options  
     *
     * @var string
     * @access private 
     */
    var $yyGlobalName = '_PHP_PARSER_STRUCTURE';

    /**
     * Global Variable helper routine
     * @param string global variable name
     * @access private
     */
    function _initGlobal($name)
    {
        if ($this->yyLex->globalSearch($name)) {
            $lc = $this->yyLex->getLastComment();
            $global = array('name' => $name,
                            'documentation' => $lc[0],
                            'line' => $this->yyLex->line);
            $this->globals[$name][] = $global;
            $this->_inGlobal = true;
        }
    }

    /**
     * Global Variable helper routine
     * @param string global variable name
     * @param string global variable initial value
     * @access private
     */
    function _processGlobal($name, $value)
    {
        if (isset($this->globals[$name])) {
            // found a global variable we are documenting
            $index = count($this->globals[$name]) - 1;
            $global = $this->globals[$name][$index];
            $global['value'] = $value;
            if ($this->_options['globalContainer']) {
                $container = $this->_options['globalContainer'];
                $globalv = new $container;
                $globalv->setParsedData($global);
            } else {
                $globalv = $global;
            }
            $this->globals[$name][$index] = $globalv;
            // publish the newly parsed global variable, if global variables should be published
            if ($this->_options['publisher'] && $this->_options['publishGlobals']) {
                $publish = $this->_options['publishMethod'];
                $message = 'method';
                if ($this->_options['publishGlobalMessage']) {
                    $message = $this->_options['publishGlobalMessage'];
                }
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $globalv);
            }
        }
    }
    
    /**
     * For use with MsgServer
     * @param string ignored
     * @param object|array file-level documentation
     */
    function getFileDocs($messagetype, $message)
    {
        $this->documentation = $message;
    }
%}

%token T_INCLUDE 257
%token T_INCLUDE_ONCE 258
%token T_EVAL 259
%token T_REQUIRE 260
%token T_REQUIRE_ONCE 261
%token T_LOGICAL_OR 262
%token T_LOGICAL_XOR 263
%token T_LOGICAL_AND 264
%token T_PRINT 265
%token T_PLUS_EQUAL 266
%token T_MINUS_EQUAL 267
%token T_MUL_EQUAL 268
%token T_DIV_EQUAL 269
%token T_CONCAT_EQUAL 270
%token T_MOD_EQUAL 271
%token T_AND_EQUAL 272
%token T_OR_EQUAL 273
%token T_XOR_EQUAL 274
%token T_SL_EQUAL 275
%token T_SR_EQUAL 276
%token T_BOOLEAN_OR 277
%token T_BOOLEAN_AND 278
%token T_IS_EQUAL 279
%token T_IS_NOT_EQUAL 280
%token T_IS_IDENTICAL 281
%token T_IS_NOT_IDENTICAL 282
%token T_IS_SMALLER_OR_EQUAL 283
%token T_IS_GREATER_OR_EQUAL 284
%token T_SL 285
%token T_SR 286
%token T_INC 287
%token T_DEC 288
%token T_INT_CAST 289
%token T_DOUBLE_CAST 290
%token T_STRING_CAST 291
%token T_ARRAY_CAST 292
%token T_OBJECT_CAST 293
%token T_BOOL_CAST 294
%token T_UNSET_CAST 295
%token T_NEW 296
%token T_INSTANCEOF 297
%token T_EXIT 298
%token T_IF 299
%token T_ELSEIF 300
%token T_ELSE 301
%token T_ENDIF 302
%token T_LNUMBER 303
%token T_DNUMBER 304
%token T_STRING 305
%token T_STRING_VARNAME 306
%token T_VARIABLE 307
%token T_NUM_STRING 308
%token T_INLINE_HTML 309
%token T_CHARACTER 310
%token T_BAD_CHARACTER 311
%token T_ENCAPSED_AND_WHITESPACE 312
%token T_CONSTANT_ENCAPSED_STRING 313
%token T_ECHO 314
%token T_DO 315
%token T_WHILE 316
%token T_ENDWHILE 317
%token T_FOR 318
%token T_ENDFOR 319
%token T_FOREACH 320
%token T_ENDFOREACH 321
%token T_DECLARE 322
%token T_ENDDECLARE 323
%token T_AS 324
%token T_SWITCH 325
%token T_ENDSWITCH 326
%token T_CASE 327
%token T_DEFAULT 328
%token T_BREAK 329
%token T_CONTINUE 330
%token T_FUNCTION 331
%token T_CONST 332
%token T_RETURN 333
%token T_TRY 334
%token T_CATCH 335
%token T_THROW 336
%token T_USE 337
%token T_GLOBAL 338
%token T_STATIC 339
%token T_ABSTRACT 340
%token T_FINAL 341
%token T_PRIVATE 342
%token T_PROTECTED 343
%token T_PUBLIC 344
%token T_VAR 345
%token T_UNSET 346
%token T_ISSET 347
%token T_EMPTY 348
%token T_CLASS 349
%token T_INTERFACE 350
%token T_EXTENDS 351
%token T_IMPLEMENTS 352
%token T_OBJECT_OPERATOR 353
%token T_DOUBLE_ARROW 354
%token T_LIST 355
%token T_ARRAY 356
%token T_CLASS_C 357
%token T_METHOD_C 358
%token T_FUNC_C 359
%token T_LINE 360
%token T_FILE 361
%token T_COMMENT 362
%token T_DOC_COMMENT 363
%token T_OPEN_TAG 364
%token T_OPEN_TAG_WITH_ECHO 365
%token T_CLOSE_TAG 366
%token T_WHITESPACE 367
%token T_START_HEREDOC 368
%token T_END_HEREDOC 369
%token T_DOLLAR_OPEN_CURLY_BRACES 370
%token T_CURLY_OPEN 371
%token T_PAAMAYIM_NEKUDOTAYIM 372
%token T_CLONE 373

%right T_STATIC T_ABSTRACT T_FINAL T_PRIVATE T_PROTECTED T_PUBLIC
%left T_ELSEIF
%left T_ELSE
%left T_ENDIF
%left T_INCLUDE T_INCLUDE_ONCE T_EVAL T_REQUIRE T_REQUIRE_ONCE
%left ','
%left T_LOGICAL_OR
%left T_LOGICAL_XOR
%left T_LOGICAL_AND
%right T_PRINT
%left '=' T_PLUS_EQUAL T_MINUS_EQUAL T_MUL_EQUAL T_DIV_EQUAL T_CONCAT_EQUAL T_MOD_EQUAL T_AND_EQUAL T_OR_EQUAL T_XOR_EQUAL T_SL_EQUAL T_SR_EQUAL
%left '?' ':'
%left T_BOOLEAN_OR
%left T_BOOLEAN_AND
%left '|'
%left '^'
%left '&'
%nonassoc T_IS_EQUAL T_IS_NOT_EQUAL T_IS_IDENTICAL T_IS_NOT_IDENTICAL
%nonassoc '<' T_IS_SMALLER_OR_EQUAL '>' T_IS_GREATER_OR_EQUAL
%left T_SL T_SR
%left '+' '-' '.'
%left '*' '/' '%'
%right '!'
%nonassoc T_INSTANCEOF
%right '~' T_INC T_DEC T_INT_CAST T_DOUBLE_CAST T_STRING_CAST T_ARRAY_CAST T_OBJECT_CAST T_BOOL_CAST T_UNSET_CAST '@'
%right '['
%nonassoc T_NEW T_CLONE

%start top_statement_list

%% /* Rules */

top_statement_list:
        top_statement_list  top_statement
    |    /* empty */
;

top_statement:
        statement
    |    function_declaration_statement    
    |    class_declaration_statement
;


inner_statement_list:
        inner_statement_list inner_statement 
    |    /* empty */
;


inner_statement:
        statement
    |    function_declaration_statement
    |    class_declaration_statement
;


statement:
        unticked_statement 
;

unticked_statement:
        '{' inner_statement_list '}'
    |    T_IF '(' expr ')'  statement  elseif_list else_single 
    |    T_IF '(' expr ')' ':'  inner_statement_list  new_elseif_list new_else_single T_ENDIF ';' 
    |    T_WHILE '('  expr  ')'  while_statement 
    |    T_DO  statement T_WHILE '('  expr ')' ';' 
    |    T_FOR 
            '('
                for_expr
            ';' 
                for_expr
            ';' 
                for_expr
            ')' 
            for_statement 
    |    T_SWITCH '(' expr ')'     switch_case_list 
    |    T_BREAK ';'                
    |    T_BREAK expr ';'        
    |    T_CONTINUE ';'            
    |    T_CONTINUE expr ';'        
    |    T_RETURN ';'                        
    |    T_RETURN expr_without_variable ';'
    {
        if (isset($this->returns)) {
            $this->returns[] = trim($2);
        }
    }
    |    T_RETURN variable ';'
    {
        if (isset($this->returns)) {
            $this->returns[] = trim($2);
        }
    }
    |    T_GLOBAL global_var_list ';'
    |    T_STATIC static_var_list ';'
    |    T_ECHO echo_expr_list ';'
    |    T_INLINE_HTML            
    |    expr ';'                
    |    T_USE use_filename ';'
    |    T_UNSET '(' unset_variables ')' ';'
    |    T_FOREACH '(' variable T_AS foreach_variable foreach_optional_arg ')' foreach_statement

    |    T_FOREACH '(' expr_without_variable T_AS w_variable foreach_optional_arg ')'  foreach_statement 
    |    T_DECLARE  '(' declare_list ')' declare_statement 
    |    ';'        /* empty statement */
    |    T_TRY  '{' inner_statement_list '}'
        T_CATCH '(' fully_qualified_class_name T_VARIABLE ')'  '{' inner_statement_list '}' 
        additional_catches
    {
        if (isset($this->catches)) {
            $this->catches[] = trim($7);
        }
        if (isset($this->referencedClasses)) {
            $this->referencedClasses[] = trim($7);
        }
    }
    |    T_THROW
    {
        $this->_get_class = true;
    } expr ';'
    {
        $this->_get_class = false;
        if (isset($this->throws)) {
            $this->throws[] = trim($3);
        }
    }
;

foreach_variable:
        w_variable
    |   '&' w_variable
;

additional_catches:
        non_empty_additional_catches
    |    /* empty */
;

non_empty_additional_catches:
        non_empty_additional_catches T_CATCH '(' fully_qualified_class_name T_VARIABLE ')'  '{' inner_statement_list '}' 
    {
        if (isset($this->catches)) {
            $this->catches[] = trim($4);
        }
        if (isset($this->referencedClasses)) {
            $this->referencedClasses[] = trim($4);
        }
    }
    |    T_CATCH '(' fully_qualified_class_name T_VARIABLE ')'  '{' inner_statement_list '}' 
    {
        if (isset($this->catches)) {
            $this->catches[] = trim($3);
        }
        if (isset($this->referencedClasses)) {
            $this->referencedClasses[] = trim($3);
        }
    }
;


unset_variables:
        unset_variable
    |    unset_variables ',' unset_variable
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
;

unset_variable:
        variable    
;

use_filename:
        T_CONSTANT_ENCAPSED_STRING
    |    '(' T_CONSTANT_ENCAPSED_STRING ')'
;


function_declaration_statement:
        unticked_function_declaration_statement    
;

class_declaration_statement:
        unticked_class_declaration_statement    
;


is_reference:
        /* empty */
    {
        $$ = false;
    }
    |    '&'
    {
        $$ = true;
    }
;


unticked_function_declaration_statement:
        T_FUNCTION  is_reference T_STRING
    {
        $this->functionLine = $this->yyLex->line; 
        $this->functionPos = $this->yyLex->pos;
        $lc = $this->yyLex->getLastComment();
        $this->functionComment = $lc[0];
        $this->functionCommentToken = $this->yyLex->lastCommentToken;
        $this->params = array();
        $this->statics = array();
        $this->funcglobals = array();
        $this->superglobals = array();
        $this->referencedClasses = array();
        $this->referencedFunctions = array();
        $this->returns = array();
        $this->throws = array();
        $this->catches = array();
        if ($this->_options['functionContainer']) {
            $container = $this->_options['functionContainer'];
            $this->functions[$3] = new $container;
            $this->functions[$3]->setReference($2);
        } else {
        }
    }
            '(' parameter_list ')'  '{' inner_statement_list '}'
    {
        $this->referencedClasses = array_values(array_unique($this->referencedClasses));
        $this->referencedFunctions = array_values(array_unique($this->referencedFunctions));
        $func = array(
                'name' => $3,
                'returnsReference' => $2,
                'params' => $this->params,
                'globals' => $this->funcglobals,
                'statics' => $this->statics,
                'throws' => $this->throws,
                'catches' => $this->catches,
                'referencedFunctions' => $this->referencedFunctions,
                'referencedClasses' => $this->referencedClasses,
                'returns' => $this->returns,
                'superglobals' => $this->superglobals,
                'startline' => $this->functionLine,
                'endline' => $this->yyLex->line,
                'documentation' => $this->functionComment,
                );
        if ($this->_options['functionContainer']) {
            $container = $this->_options['functionContainer'];
            $funct = new $container;
            $funct->setParsedData($func);
        } else {
            $funct = $func;
        }
        $this->functions[$3][] = $funct;
        // publish the newly parsed function, if functions should be published
        if ($this->_options['publisher'] && $this->_options['publishFunctions']) {
            $publish = $this->_options['publishMethod'];
            $message = 'function';
            if ($this->_options['publishFunctionMessage']) {
                $message = $this->_options['publishFunctionMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $funct);
        }
        unset($this->params);
        unset($this->returns);
        unset($this->statics);
        unset($this->funcglobals);
        unset($this->superglobals);
        unset($this->throws);
        unset($this->referencedClasses);
    }
;

unticked_class_declaration_statement:
    class_entry_type
    {
        $this->classLine = $this->yyLex->line; 
        $this->classPos = $this->yyLex->pos;
        $lc = $this->yyLex->getLastComment();
        $this->classComment = $lc[0];
        $this->classCommentToken = $this->yyLex->lastCommentToken;
    } T_STRING extends_from
    {
        $this->methods = array();
        $this->vars = array();
        $this->consts = array();
        $this->implementsInterfaces = array();
    } 
            implements_list
            '{'
                class_statement_list
            '}'
    {
        $name = trim($3);
        $cls = array(
                 'extends' => trim($4),
                 'type' => $2,
                 'methods' => $this->methods,
                 'vars' => $this->vars,
                 'consts' => $this->consts,
                 'implements' => $this->implementsInterfaces,
                 'startline' => $this->classLine,
                 'endline' => $this->yyLex->line,
                 'documentation' => $this->classComment,
                 );
        if ($this->_options['classContainer']) {
            $container = $this->_options['classContainer'];
            $classc = new $container;
            $classc->setParsedData($cls);
        } else {
            // use arrays if no class container is defined
            $classc = $cls;
        }
        $this->classes[trim($name)][] = $classc;
        // publish the newly parsed class, if classes should be published
        if ($this->_options['publisher'] && $this->_options['publishClasses']) {
            $publish = $this->_options['publishMethod'];
            $message = 'class';
            if ($this->_options['publishClassMessage']) {
                $message = $this->_options['publishClassMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $classc);
        }
        unset($this->methods);
        unset($this->vars);
        unset($this->consts);
        unset($this->throws);
        unset($this->implementsInterfaces);
    }
    |   interface_entry
    {
        $this->classLine = $this->yyLex->line; 
        $this->classPos = $this->yyLex->pos;
        $lc = $this->yyLex->getLastComment();
        $this->classComment = $lc[0];
        $this->classCommentToken = $this->yyLex->lastCommentToken;
        $this->implementsInterfaces = array();
    } T_STRING interface_extends_list
    {
        $this->methods = array();
    } 
    '{' class_statement_list '}'
    {
        $name = trim($3);
        $interf = array(
                 'methods' => $this->methods,
                 'extends' => $this->implementsInterfaces,
                 'startline' => $this->classLine,
                 'endline' => $this->yyLex->line,
                 'documentation' => $this->classComment,
                 );
        if ($this->_options['interfaceContainer']) {
            $container = $this->_options['interfaceContainer'];
            $int = new $container;
            $int->setParsedData($interf);
        } else {
            // use arrays if no class container is defined
            $int = $interf;
        }
        $this->interfaces[$name][] = $int;
        // publish the newly parsed class, if classes should be published
        if ($this->_options['publisher'] && $this->_options['publishInterfaces']) {
            $publish = $this->_options['publishMethod'];
            $message = 'class';
            if ($this->_options['publishInterfaceMessage']) {
                $message = $this->_options['publishInterfaceMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $int);
        }
        unset($this->methods);
        unset($this->implementsInterfaces);
    }
 ;


class_entry_type:
        T_CLASS
    {
        $$ = '';
    }
    |    T_ABSTRACT T_CLASS
    {
        $$ = 'abstract';
    }
    |    T_FINAL T_CLASS
    {
        $$ = 'final';
    }
;

extends_from:
        /* empty */
    {
        $$ = '';
    }
    |    T_EXTENDS fully_qualified_class_name
    {
        $$ = $2;
    }
;

interface_entry:
    T_INTERFACE
    {
        $$ = 'interface';
    }
;

interface_extends_list:
        /* empty */
    |   T_EXTENDS interface_list
;

implements_list:
        /* empty */
    |    T_IMPLEMENTS interface_list
;

interface_list:
        fully_qualified_class_name
    {
        if (isset($this->implementsInterfaces)) {
            $this->implementsInterfaces[] = trim($1);
        }
    }
    |    interface_list ',' fully_qualified_class_name
    {
        if (isset($this->implementsInterfaces)) {
            $this->implementsInterfaces[] = trim($3);
        }
    }
;

foreach_optional_arg:
        /* empty */                
    |    T_DOUBLE_ARROW w_variable
;

for_statement:
        statement
    |    ':' inner_statement_list T_ENDFOR ';'
;


foreach_statement:
        statement
    |    ':' inner_statement_list T_ENDFOREACH ';'
;


declare_statement:
        statement
    |    ':' inner_statement_list T_ENDDECLARE ';'
;


declare_list:
        T_STRING '=' static_scalar                    
    |    declare_list ',' T_STRING '=' static_scalar    
;


switch_case_list:
        '{' case_list '}'                    
    |    '{' ';' case_list '}'                
    |    ':' case_list T_ENDSWITCH ';'        
    |    ':' ';' case_list T_ENDSWITCH ';'    
;


case_list:
        /* empty */    
    |    case_list T_CASE expr case_separator  inner_statement_list 
    |    case_list T_DEFAULT case_separator  inner_statement_list 
;


case_separator:
        ':'
    |    ';'
;


while_statement:
        statement
    |    ':' inner_statement_list T_ENDWHILE ';'
;



elseif_list:
        /* empty */
    |    elseif_list T_ELSEIF '(' expr ')'  statement 
;


new_elseif_list:
        /* empty */
    |    new_elseif_list T_ELSEIF '(' expr ')' ':'  inner_statement_list 
;


else_single:
        /* empty */
    |    T_ELSE statement
;


new_else_single:
        /* empty */
    |    T_ELSE ':' inner_statement_list
;


parameter_list: 
        non_empty_parameter_list
    |    /* empty */
;


non_empty_parameter_list:
        optional_class_type T_VARIABLE
    {
        $this->params[$2] = array('default' => null, 'type' => $1, 'isReference' => false);
    }
    |    optional_class_type '&' T_VARIABLE
    {
        $this->params[$3] = array('default' => null, 'type' => $1, 'isReference' => true);
    }
    |    optional_class_type '&' T_VARIABLE '=' static_scalar
    {
        $this->params[$3] = array('default' => trim($5), 'type' => $1, 'isReference' => true);
    }
    |    optional_class_type T_VARIABLE '=' static_scalar
    {
        $this->params[$2] = array('default' => trim($4), 'type' => $1, 'isReference' => false);
    }
    |    non_empty_parameter_list ',' optional_class_type T_VARIABLE
    {
        $this->params[$4] = array('default' => null, 'type' => $3, 'isReference' => false);
    }
    |    non_empty_parameter_list ',' optional_class_type '&' T_VARIABLE
    {
        $this->params[$5] = array('default' => null, 'type' => $3, 'isReference' => true);
    }
    |    non_empty_parameter_list ',' optional_class_type '&' T_VARIABLE     '=' static_scalar
    {
        $this->params[$5] = array('default' => trim($7), 'type' => $3, 'isReference' => true);
    }
    |    non_empty_parameter_list ',' optional_class_type T_VARIABLE '=' static_scalar
    {
        $this->params[$4] = array('default' => trim($6), 'type' => $3, 'isReference' => false);
    }
;


optional_class_type:
        /* empty */        
    {
        $$ = '';
    }
    |    T_STRING
    {
        $$ = $1;
    }
;


function_call_parameter_list:
    non_empty_function_call_parameter_list
    |    /* empty */                
    {
        $$ = '';
    }
;


non_empty_function_call_parameter_list:
        expr_without_variable
    |    variable                
    |    '&' w_variable                 
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    non_empty_function_call_parameter_list ',' expr_without_variable
    {
        if ($this->_grabDefine) {
            $this->defineName = trim($1);
            $this->defineValue = trim($3);
        }
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    non_empty_function_call_parameter_list ',' variable                    
    {
        if ($this->_grabDefine) {
            $this->defineName = trim($1);
            $this->defineValue = trim($3);
        }
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    non_empty_function_call_parameter_list ',' '&' w_variable                
    {
        if ($this->_grabDefine) {
            $this->defineName = trim($1);
            $this->defineValue = '&' . trim($4);
        }
        $$ = $1 . $this->yW[$yyTop - 2] . $this->yW[$yyTop - 1] . $4;
    }
;

global_var_list:
        global_var_list ',' global_var
    |    global_var
;


global_var:
        T_VARIABLE    
    {
        $this->funcglobals[] = $1;
    }
    |    '$' r_variable
    {
        $this->funcglobals[] = '$' . $1;
    }
    |    '$' '{' expr '}'
    {
        $this->funcglobals[] = '${' . $3 . '}';
    }
;


static_var_list:
        static_var_list ',' T_VARIABLE
    {
        $this->statics[] = array('name' => $3, 'default' => null);
    }
    |    static_var_list ',' T_VARIABLE '=' static_scalar
    {
        $this->statics[] = array('name' => $3, 'default' => trim($5));
    }
    |    T_VARIABLE
    {
        $this->statics[] = array('name' => $1, 'default' => null);
    }
    |    T_VARIABLE '=' static_scalar
    {
        $this->statics[] = array('name' => $1, 'default' => trim($3));
    }
;


class_statement_list:
        class_statement_list class_statement
    |    /* empty */
;


class_statement:
        variable_modifiers class_variable_declaration
    {
        foreach($2 as $var) {
            $is_static = false;
            if (in_array('static', $1)) {
                $is_static = true;
                $z = array_flip($1);
                unset($1[$z['static']]);
            }
            if ($this->_options['varContainer']) {
                $var->setAccess($1);
                if ($is_static) {
                    $var->setStatic();
                }
            } else {
                $var['access'] = $1;
                $var['static'] = $is_static;
            }
            if ($is_static) {
                $1[$z['static']] = 'static';
            }
            $this->vars[$var['name']] = $var;
            // publish the newly parsed var, if vars should be published
            if ($this->_options['publisher'] && $this->_options['publishVars']) {
                $publish = $this->_options['publishMethod'];
                $message = 'var';
                if ($this->_options['publishVarMessage']) {
                    $message = $this->_options['publishVarMessage'];
                }
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $var);
            }
        }
    } ';'
    |    class_constant_declaration ';'
    |   method_modifiers T_FUNCTION 
    {
        $this->methodLine = $this->yyLex->line; 
        $this->methodPos = $this->yyLex->pos;
        $lc = $this->yyLex->getLastComment();
        $this->methodComment = $lc[0];
        $this->methodCommentToken = $this->yyLex->lastCommentToken;
    }
    is_reference T_STRING
    {
        $this->throws = array();
        $this->catches = array();
        $this->params = array();
        $this->returns = array();
        $this->referencedVars = array();
        $this->referencedMethods = array();
        $this->referencedFunctions = array();
        $this->referencedClasses = array();
        $this->statics = array();
        $this->funcglobals = array();
        $this->superglobals = array();
    } '(' 
            parameter_list ')' method_body
    {
        $is_static = false;
        $is_abstract = false;
        if (in_array('static', $1)) {
            $is_static = true;
            $z = array_flip($1);
            unset($1[$z['static']]);
        }
        if (in_array('abstract', $1)) {
            $is_abstract = true;
            $z = array_flip($1);
            unset($1[$z['abstract']]);
        }
        // remove duplicates
        $this->referencedClasses = array_values(array_unique($this->referencedClasses));
        $this->referencedFunctions = array_values(array_unique($this->referencedFunctions));
        $ar = $this->referencedMethods;
        foreach ($ar as $key => $val) {
            $this->referencedMethods[$key] = array_values(array_unique($val));
        }
        $ar = $this->referencedVars;
        foreach ($ar as $key => $val) {
            $this->referencedVars[$key] = array_values(array_unique($val));
        }
        $method = array(
                'name' => $5,
                'access' => array_values($1),
                'static' => $is_static,
                'abstract' => $is_abstract,
                'returnsReference' => $4,
                'params' => $this->params,
                'globals' => $this->funcglobals,
                'statics' => $this->statics,
                'throws' => $this->throws,
                'catches' => $this->catches,
                'referencedFunctions' => $this->referencedFunctions,
                'referencedVars' => $this->referencedVars,
                'referencedMethods' => $this->referencedMethods,
                'referencedClasses' => $this->referencedClasses,
                'returns' => $this->returns,
                'superglobals' => $this->superglobals,
                'startline' => $this->methodLine,
                'endline' => $this->yyLex->line,
                'documentation' => $this->methodComment,
                );
        if ($this->_options['methodContainer']) {
            $container = $this->_options['methodContainer'];
            $this->methods[$5] = new $container;
            $this->methods[$5]->setParsedData($method);
        } else {
            $this->methods[$5] = $method;
        }
        // publish the newly parsed method, if methods should be published
        if ($this->_options['publisher'] && $this->_options['publishMethods']) {
            $publish = $this->_options['publishMethod'];
            $message = 'method';
            if ($this->_options['publishMethodMessage']) {
                $message = $this->_options['publishMethodMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $this->methods[$5]);
        }
        unset($this->returns);
        unset($this->referencedFunctions);
        unset($this->referencedVars);
        unset($this->referencedMethods);
        unset($this->referencedClasses);
        unset($this->statics);
        unset($this->throws);
        unset($this->catches);
        unset($this->funcglobals);
        unset($this->superglobals);
    }
;


method_body:
        ';' /* abstract method */        
    |    '{' inner_statement_list '}'    
;

variable_modifiers:
        non_empty_member_modifiers
    {
        $$ = $1;
    }
    |    T_VAR
    {
        $$ = array('public');
    }
;

method_modifiers:
        /* empty */
    {
        $$ = array('public');
    }
    |    non_empty_member_modifiers
    {
        $$ = $1;
    }
;

non_empty_member_modifiers:
        member_modifier
    {
        $$ = array($1);
    }
    |    non_empty_member_modifiers member_modifier
    {
        $$ = $1;
        $$[] = $2;
    }
;

member_modifier:
        T_PUBLIC
    {
        $$ = 'public';
    }
        |    T_PROTECTED
    {
        $$ = 'protected';
    }
       |    T_PRIVATE
    {
        $$ = 'private';
    }
       |    T_STATIC
    {
        $$ = 'static';
    }
       |    T_ABSTRACT
    {
        $$ = 'abstract';
    }
       |    T_FINAL
    {
        $$ = 'final';
    }
;

class_variable_declaration:
        class_variable_declaration ',' T_VARIABLE
    {
        $$ = $1;
        if ($this->_options['varContainer']) {
            $container = $this->_options['varContainer'];
            $var = new $container;
            $var->setName($3);
            $var->setStartLine($this->yyLex->line);
            $var->setEndLine($this->yyLex->line);
            $lc = $this->yyLex->getLastComment();
            $var->setDocumentation($lc[0]);
            $$[] = $var;
        } else {
            $lc = $this->yyLex->getLastComment();
            $$[] = array('name' => $3,
                         'startline' => $this->_varLine,
                         'endline' => $this->yyLex->line,
                         'documentation' => $lc[0],
                         'default' => null);
        }
    }
    |    class_variable_declaration ','
     T_VARIABLE
    {
        $this->_varLine = $this->yyLex->line;
        
    } '=' static_scalar
    {
        $$ = $1;
        if ($this->_options['varContainer']) {
            $container = $this->_options['varContainer'];
            $var = new $container;
            $var->setName($3);
            $var->setStartLine($this->_varLine);
            $var->setEndLine($this->yyLex->line);
            $lc = $this->yyLex->getLastComment();
            $var->setDocumentation($lc[0]);
            $var->setDefault(trim($6));
            $$[] = $var;
        } else {
            $lc = $this->yyLex->getLastComment();
            $$[] = array('name' => $3,
                         'startline' => $this->yyLex->line,
                         'endline' => $this->yyLex->line,
                         'documentation' => $lc[0],
                         'default' => trim($6));
        }
    }
    |
    T_VARIABLE
    {
        if ($this->_options['varContainer']) {
            $container = $this->_options['varContainer'];
            $var = new $container;
            $var->setName($1);
            $var->setStartLine($this->yyLex->line);
            $var->setEndLine($this->yyLex->line);
            $lc = $this->yyLex->getLastComment();
            $var->setDocumentation($lc[0]);
            $$ = array($var);
        } else {
            $lc = $this->yyLex->getLastComment();
            $$ = array(array('name' => $1,
                             'startline' => $this->yyLex->line,
                             'endline' => $this->yyLex->line,
                             'documentation' => $lc[0],
                             'default' => null));
        }
    }
    |
     T_VARIABLE {
        $this->_varLine = $this->yyLex->line;
    } '=' static_scalar
    {
        if ($this->_options['varContainer']) {
            $container = $this->_options['varContainer'];
            $var = new $container;
            $var->setName($1);
            $var->setStartLine($this->_varLine);
            $var->setEndLine($this->yyLex->line);
            $lc = $this->yyLex->getLastComment();
            $var->setDocumentation($lc[0]);
            $var->setDefault(trim($4));
            $$ = array($var);
        } else {
            $lc = $this->yyLex->getLastComment();
            $$ = array(array('name' => $1,
                             'startline' => $this->_varLine,
                             'endline' => $this->yyLex->line,
                             'documentation' => $lc[0],
                             'default' => trim($4)));
        }
    }
;

class_constant_declaration:
        class_constant_declaration ',' T_STRING
    {
        $lc = $this->yyLex->getLastComment();
        $this->constLine = $this->yyLex->line;
        $this->constComment = $lc[0];
    } '=' static_scalar
    {
        $constinfo = array('name' => $3,
                       'value' => trim($6),
                       'startline' => $this->constLine,
                       'endline' => $this->yyLex->line,
                       'documentation' => $this->constComment);
        if ($this->_options['classConstContainer']) {
            $container = $this->_options['classConstContainer'];
            $const = new $container;
            $const->setParsedData($constinfo);
        } else {
            $const = $constinfo;
        }
        $this->consts[$3] = $const;
        // publish the newly parsed class constant, if class constants should be published
        if ($this->_options['publisher'] && $this->_options['publishClassConsts']) {
            $publish = $this->_options['publishMethod'];
            $message = 'method';
            if ($this->_options['publishClassConstantMessage']) {
                $message = $this->_options['publishClassConstantMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $const);
        }
    }
    |
    T_CONST {
        $this->constLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->constComment = $lc[0];
    } T_STRING '=' static_scalar
    {
        $constinfo = array('name' => $3,
                       'value' => trim($5),
                       'startline' => $this->constLine,
                       'endline' => $this->yyLex->line,
                       'documentation' => $this->constComment);
        if ($this->_options['classConstContainer']) {
            $container = $this->_options['classConstContainer'];
            $const = new $container;
            $const->setParsedData($constinfo);
        } else {
            $const = $constinfo;
        }
        $this->consts[$3] = $const;
        // publish the newly parsed class constant, if class constants should be published
        if ($this->_options['publisher'] && $this->_options['publishClassConsts']) {
            $publish = $this->_options['publishMethod'];
            $message = 'method';
            if ($this->_options['publishClassConstantMessage']) {
                $message = $this->_options['publishClassConstantMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $const);
        }
    }
;

echo_expr_list:    
        echo_expr_list ',' expr 
    |    expr                    
;


for_expr:
        /* empty */            
    |    non_empty_for_expr
;

non_empty_for_expr:
        non_empty_for_expr ','     expr 
    |    expr
;

expr_without_variable:    
        T_LIST '('  assignment_list ')' '=' expr
    {
        $$ = $this->yW[$yyTop - 5] . $this->yW[$yyTop - 4] . $3 . 
            $this->yW[$yyTop - 2] . $this->yW[$yyTop - 1] . $6;
    }
    |    variable '='
    {
        $this->_initGlobal(trim($1));
    } expr
    {
        if ($this->_inGlobal) {
            $this->_processGlobal($1, $4);
        }
        $$ = $1 . $this->yW[$yyTop - 1] . $4;
    }
    |    variable '=' '&'
    {
        $this->_initGlobal($1);
    } variable
    {
        if ($this->_inGlobal) {
            $this->_processGlobal($1, '&' . $5);
        }
        $$ = $1 . $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $5;
    }
    |    variable '=' '&' T_NEW
    {
        $this->_initGlobal($1);
    } class_name_reference  ctor_arguments 
    {
        if ($this->_inGlobal) {
            $this->_processGlobal($1, '&' . $this->yW[$yyTop - 4] . $6 . $7);
        }
        if ($this->_get_class) {
            $$ = $6;
        } else {
            $$ = $1 . $this->yW[$yyTop - 5]. $this->yW[$yyTop - 4] . $this->yW[$yyTop - 3] . $6 . $7;
        }
    }
    |    T_NEW class_name_reference  ctor_arguments
    {
        if ($this->_get_class) {
            $$ = $2;
        } else {
            $$ = $this->yW[$yyTop - 2] . $2 . $3;
        }
    }
    |   T_CLONE expr
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    variable T_PLUS_EQUAL expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_MINUS_EQUAL expr    
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_MUL_EQUAL expr        
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_DIV_EQUAL expr        
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_CONCAT_EQUAL expr    
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_MOD_EQUAL expr        
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_AND_EQUAL expr        
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_OR_EQUAL expr         
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_XOR_EQUAL expr         
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_SL_EQUAL expr     
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    variable T_SR_EQUAL expr     
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    rw_variable T_INC 
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    T_INC rw_variable 
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    rw_variable T_DEC 
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    T_DEC rw_variable 
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    expr T_BOOLEAN_OR  expr 
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_BOOLEAN_AND  expr   
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_LOGICAL_OR  expr 
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_LOGICAL_AND  expr 
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_LOGICAL_XOR expr 
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '|' expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '&' expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '^' expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '.' expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '+' expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '-' expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '*' expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '/' expr    
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '%' expr     
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |     expr T_SL expr    
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_SR expr    
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    '+' expr 
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    '-' expr 
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    '!' expr 
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    '~' expr 
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    expr T_IS_IDENTICAL expr        
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_IS_NOT_IDENTICAL expr    
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_IS_EQUAL expr            
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_IS_NOT_EQUAL expr         
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '<' expr                     
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_IS_SMALLER_OR_EQUAL expr 
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr '>' expr                     
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_IS_GREATER_OR_EQUAL expr 
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_INSTANCEOF class_name_reference 
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    '(' expr ')'
    {
        if ($this->_get_class) {
            $$ = $2;
        } else {
            $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
        }
    }
    |    expr '?' 
        expr ':' 
        expr
    {
        $$ = $1 . $this->yW[$yyTop - 3] . $3 . $this->yW[$yyTop - 1] . $5;
    }
    |    internal_functions_in_yacc
    |    T_INT_CAST expr
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    T_DOUBLE_CAST expr     
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    T_STRING_CAST expr     
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    T_ARRAY_CAST expr     
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    T_OBJECT_CAST expr     
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    T_BOOL_CAST expr    
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    T_UNSET_CAST expr    
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    T_EXIT exit_expr
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    '@'  expr
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    scalar
    |    T_ARRAY '(' array_pair_list ')'
    {
        $$ = $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $3
            . $this->yW[$yyTop];
    }
    |    '`' encaps_list '`'
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
    |    T_PRINT expr
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
;

function_call:
        T_STRING '('
    {
        if (strtolower($1) == 'define') {
            $this->defineLine = $this->yyLex->line;
            $lc = $this->yyLex->getLastComment();
            $this->defineComment = $lc[0];
            $this->_grabDefine = true;
            $this->defineName = '';
            $this->defineValue = '';
        }
    } function_call_parameter_list ')'
    {
        if (isset($this->referencedFunctions)) {
            $this->referencedFunctions[] = $1;
        }
        if ($this->_grabDefine && !empty($this->defineName)) {
            // attempt to determine whether this is a simple string
            $test = token_get_all('<?php ;' . $this->defineName);
            $simple = false;
            if (count($test) == 3 && $test[2][0] == T_CONSTANT_ENCAPSED_STRING) {
                // it's a simple define
                $this->defineName = substr($this->defineName, 1, strlen($this->defineName) - 2);
                $simple = true;
            }
            $const = array('name' => $this->defineName,
                           'value' => $this->defineValue,
                           'simple' => $simple,
                           'startline' => $this->defineLine,
                           'endline' => $this->yyLex->line,
                           'documentation' => $this->defineComment);
            if ($this->_options['constContainer']) {
                $container = $this->_options['constContainer'];
                $constant = new $container;
                $constant->setParsedData($const);
            } else {
                $constant = $const;
            }
            $this->constants[$this->defineName][] = $constant;
            // publish the newly parsed class constant, if class constants should be published
            if ($this->_options['publisher'] && $this->_options['publishConsts']) {
                $publish = $this->_options['publishMethod'];
                $message = 'method';
                if ($this->_options['publishConstantMessage']) {
                    $message = $this->_options['publishConstantMessage'];
                }
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $constant);
            }
        }
        $this->_grabDefine = false;
        $$ = $this->yW[$yyTop - 4] . $this->yW[$yyTop - 3] . $4 . $this->yW[$yyTop];
    }
    |    class_constant '(' function_call_parameter_list ')'
    {
        $this->referencedMethods[$this->_lastClassname][] = $this->_lastConst;
        $$ = $1 . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |   static_member '('
    {
    } function_call_parameter_list ')'
    {
        if (isset($this->referencedVars)) {
            foreach ($this->referencedVars[$this->_lastClassname] as $i => $var) {
                if ($var == $this->_lastVar) {
                    break;
                }
            }
            unset ($this->referencedVars[$this->_lastClassname][$i]);
            if (!count($this->referencedVars[$this->_lastClassname])) {
                unset($this->referencedVars[$this->_lastClassname]);
            }
            $this->referencedMethods[$this->_lastClassname][] = $this->_lastVar;
        }
        $$ = $1 . $this->yW[$yyTop - 3] . $4 . $this->yW[$yyTop];
    }
    |    variable_without_objects  '(' 
            function_call_parameter_list ')'
    {
        $$ = $1 . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
            
;

fully_qualified_class_name:
        T_STRING
    {
        if (isset($this->referencedClasses) && strtolower($1) != 'self' && strtolower($1) != 'parent') {
            $this->referencedClasses[] = $1;
        }
        $$ = $this->yW[$yyTop];
    }
;

class_name_reference:
        T_STRING                
        {
            $$ = $this->yW[$yyTop];
            if (isset($this->referencedClasses)) {
                $this->referencedClasses[] = $1;
            }
        }
    |    dynamic_class_name_reference
    {
        $$ = $1;
    }
;


dynamic_class_name_reference:
        base_variable T_OBJECT_OPERATOR 
            object_property  dynamic_class_name_variable_properties
            {
                $$ = $1 . $this->yW[$yyTop - 2] . $3 . $4;
            }
    |    base_variable
;


dynamic_class_name_variable_properties:
        dynamic_class_name_variable_properties dynamic_class_name_variable_property
        {
            $$ = $1 . $2;
        }
    |    /* empty */
;


dynamic_class_name_variable_property:
        T_OBJECT_OPERATOR object_property 
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
;

exit_expr:
        /* empty */        
    {
        $$ = '';
    }
    |    '(' ')'            
    {
        $$ = $this->yW[$yyTop - 1] . $this->yW[$yyTop];
    }
    |    '(' expr ')'    
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
;


ctor_arguments:
        /* empty */    
    {
        $$ = '';
    }
    |    '(' function_call_parameter_list ')'
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
;


common_scalar:
        T_LNUMBER
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_DNUMBER
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_CONSTANT_ENCAPSED_STRING
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_LINE
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_FILE
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_CLASS_C
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_FUNC_C
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_METHOD_C
    {
        $$ = $this->yW[$yyTop];
    }
;

static_scalar: /* compile-time evaluated scalars */
        common_scalar
    |    T_STRING
    {
        $$ = $this->yW[$yyTop];
    }
    |    '+' static_scalar
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
    |    '-' static_scalar
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    } 
    |    T_ARRAY '(' static_array_pair_list ')'
    {
        $$ = $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $3
            . $this->yW[$yyTop];
    }
    |    static_class_constant
;

static_class_constant:
        T_STRING T_PAAMAYIM_NEKUDOTAYIM T_STRING
    {
        if (isset($this->referencedClasses)) {
            $this->referencedClasses[] = $1;
        }
        $$ = $this->yW[$yyTop - 2] . $this->yW[$yyTop - 1] . $this->yW[$yyTop];
    }
;

scalar:
        T_STRING
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_STRING_VARNAME
    {
        $$ = $this->yW[$yyTop];
    }
    |    class_constant
    |    common_scalar
    |    '"' encaps_list '"'
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
    |    '\'' encaps_list '\''
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
    |    T_START_HEREDOC encaps_list T_END_HEREDOC
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
;


static_array_pair_list:
        /* empty */
    {
        $$ = '';
    }
    |    non_empty_static_array_pair_list possible_comma
    {
        $$ = $1 . $2;
    }
;

possible_comma:
        /* empty */
    {
        $$ = '';
    }
    |    ','
    {
        $$ = $this->yW[$yyTop];
    }
;

non_empty_static_array_pair_list:
        non_empty_static_array_pair_list ',' static_scalar T_DOUBLE_ARROW static_scalar
    {
        $$ = $1 . $this->yW[$yyTop - 3] . $3 . $this->yW[$yyTop - 1] . $5;
    }
    |    non_empty_static_array_pair_list ',' static_scalar
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    static_scalar T_DOUBLE_ARROW static_scalar
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    static_scalar 
;

expr:
        r_variable
    |    expr_without_variable
;


r_variable:
    variable
;


w_variable:
    variable
;

rw_variable:
    variable
;

variable:
        base_variable_with_function_calls T_OBJECT_OPERATOR object_property method_or_not variable_properties
    {
        if (isset($this->referencedVars)) {
            if (trim($1) == '$this') {
                if (!$4) {
                    $this->referencedVars['$this'][] = trim($3);
                } else {
                    $this->referencedMethods['$this'][] = trim($3);
                }
            }
        }
        $$ = $1 . $this->yW[$yyTop - 3] . $3 . $4 . $5;
    }
    |    base_variable_with_function_calls
    {
        $$ = $1;
    }
;

variable_properties:
        variable_properties variable_property 
    {
        $$ = $1 . $2;
    }
    |    /* empty */ 
    {
        $$ = '';
    }
;


variable_property:
        T_OBJECT_OPERATOR object_property  method_or_not 
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $3;
    }
;

method_or_not:
        '(' function_call_parameter_list ')' 
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }        
    |    /* empty */ 
    {
        $$ = '';
    }
;

variable_without_objects:
        reference_variable
    {
        $$ = $1;
    }
    |    simple_indirect_reference reference_variable 
    {
        $$ = $1 . $2;
    }
;

static_member:
        fully_qualified_class_name T_PAAMAYIM_NEKUDOTAYIM variable_without_objects
    {
        $this->_lastClassname = trim($1);
        $this->_lastVar = trim($3);
        $this->referencedVars[trim($1)][] = trim($3);
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
;


base_variable_with_function_calls:
        base_variable
    {
        $$ = $1;
    }
    |    function_call
    {
        $$ = $1;
    }
;


base_variable:
        reference_variable
    {
        $$ = $1;
    }
    |    simple_indirect_reference reference_variable
    {
        $$ = $1 . $2;
    }
    |    static_member
    {
        $$ = $1;
    }
;
    
reference_variable:
        reference_variable '[' dim_offset ']'
    {
        if (isset($this->superglobals)) {
            $test = trim($1);
            if ($test == '$GLOBALS' ||
                $test == '$_SERVER' ||
                $test == '$_REQUEST' ||
                $test == '$_ENV' ||
                $test == '$_GET' ||
                $test == '$_POST' ||
                $test == '$_COOKIE' ||
                $test == '$_FILES' ||
                $test == '$_SESSION') {
                $this->_get_var = false;
                $this->superglobals[] = array('array' => $test,
                                              'var' => trim($3));
            }
        } else {
            $test = trim($1);
            if ($test == '$GLOBALS' ||
                $test == '$_SERVER' ||
                $test == '$_REQUEST' ||
                $test == '$_ENV' ||
                $test == '$_GET' ||
                $test == '$_POST' ||
                $test == '$_COOKIE' ||
                $test == '$_FILES' ||
                $test == '$_SESSION') {
                $this->_get_var = false;
                $this->filesuperglobals[] = array('array' => $test,
                                              'var' => trim($3));
            }
        }
        $$ = $1 . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |    reference_variable '{' expr '}'
    {
        $$ = $1 . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |    compound_variable            
    {
        $$ = $1;
    }
;
    

compound_variable:
        T_VARIABLE
    {
        $$ = $this->yW[$yyTop];
    }
    |    '$' '{' expr '}'
    {
        $$ = $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
;

dim_offset:
        /* empty */        
    {
        $$ = '';
    }
    |    expr
;


object_property:
        object_dim_list
    |    variable_without_objects 
;

object_dim_list:
        object_dim_list '[' dim_offset ']'    
    {
        $$ = $1 . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |    object_dim_list '{' expr '}'        
    {
        $$ = $1 . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |    variable_name 
;

variable_name:
        T_STRING
    {
        $$ = $this->yW[$yyTop];
    }
    |    '{' expr '}'
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
;

simple_indirect_reference:
        '$'
    {
        $$ = $this->yW[$yyTop];
    }
    |    simple_indirect_reference '$'
    {
        $$ = $1 . $this->yW[$yyTop];
    }
;

assignment_list:
        assignment_list ',' assignment_list_element
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    assignment_list_element
;


assignment_list_element:
        variable                                
    |    T_LIST '('  assignment_list ')'    
    {
        $$ = $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |    /* empty */
    {
        $$ = '';
    }
;


array_pair_list:
        /* empty */ 
    {
        $$ = '';
    }
    |    non_empty_array_pair_list possible_comma
    {
        $$ = $1 . $2;
    }
;

non_empty_array_pair_list:
        non_empty_array_pair_list ',' expr T_DOUBLE_ARROW expr
    {
        $$ = $1 . $this->yW[$yyTop - 3] . $3 . $this->yW[$yyTop - 1] . $5;
    }
    |    non_empty_array_pair_list ',' expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr T_DOUBLE_ARROW expr
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
    |    expr
    {
        $$ = $1;
    }                 
    |    non_empty_array_pair_list ',' expr T_DOUBLE_ARROW '&' w_variable 
    {
        $$ = $1 . $this->yW[$yyTop - 4] . $3 
        . $this->yW[$yyTop - 2] . $this->yW[$yyTop - 1] . $6;
    }
    |    non_empty_array_pair_list ',' '&' w_variable 
    {
        $$ = $1 . $this->yW[$yyTop - 2] . $this->yW[$yyTop - 1] . $4;
    }
    |    expr T_DOUBLE_ARROW '&' w_variable    
    {
        $$ = $1 . $this->yW[$yyTop - 2] . $this->yW[$yyTop - 1] . $4;
    }
    |    '&' w_variable
    {
        $$ = $this->yW[$yyTop - 1] . $2;
    }
;

encaps_list:
        encaps_list encaps_var
    {
        $$ = $1 . $2;
    }
    |    encaps_list T_STRING            
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list T_NUM_STRING        
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list T_ENCAPSED_AND_WHITESPACE    
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list T_CHARACTER         
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list T_BAD_CHARACTER        
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list '['        
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list ']'        
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list '{'        
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list '}'        
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    encaps_list T_OBJECT_OPERATOR  
    {
        $$ = $1 . $this->yW[$yyTop];
    }
    |    /* empty */            
    {
        $$ = '';
    }
;



encaps_var:
        T_VARIABLE 
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_VARIABLE '['  encaps_var_offset ']'    
    {
        $$ = $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |    T_VARIABLE T_OBJECT_OPERATOR T_STRING
    {
        $$ = $this->yW[$yyTop - 2] . $this->yW[$yyTop - 1] . $this->yW[$yyTop];
    }
    |    T_DOLLAR_OPEN_CURLY_BRACES expr '}' 
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
    |    T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '[' expr ']' '}' 
    {
        $$ = $this->yW[$yyTop - 5] . $this->yW[$yyTop - 4] . $this->yW[$yyTop - 3] .
             $4 . $this->yW[$yyTop - 1] . $this->yW[$yyTop];
    }
    |    T_CURLY_OPEN variable '}'
    {
        $$ = $this->yW[$yyTop - 2] . $2 . $this->yW[$yyTop];
    }
;


encaps_var_offset:
        T_STRING
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_NUM_STRING
    {
        $$ = $this->yW[$yyTop];
    }
    |    T_VARIABLE
    {
        $$ = $this->yW[$yyTop];
    }
;


internal_functions_in_yacc:
        T_ISSET '(' isset_variables ')'
    {
        $$ = $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |    T_EMPTY '(' variable ')'    
    {
        $$ = $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |
    {
        $this->includeLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->includeComment = $lc[0];
    } T_INCLUDE expr
    {
        $inc = array('file' => trim($3),
                         'type' => 'include',
                         'startline' => $this->includeLine,
                         'endline' => $this->yyLex->line,
                         'documentation' => $this->includeComment);
        if ($this->_options['includeContainer']) {
            $container = $this->_options['includeContainer'];
            $include = new $container;
            $include->setParsedData($inc);
        } else {
            $include = $inc;
        }
        $this->includes[] = $include;
        // publish the newly parsed include, if includes should be published
        if ($this->_options['publisher'] && $this->_options['publishIncludes']) {
            $publish = $this->_options['publishMethod'];
            $message = 'include';
            if ($this->_options['publishIncludeMessage']) {
                $message = $this->_options['publishIncludeMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $include);
        }
        $$ = $this->yW[$yyTop - 1] . $3;
    }
    |
    {
        $this->includeLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->includeComment = $lc[0];
    } T_INCLUDE_ONCE expr     
    {
        $inc  = array('file' => trim($3),
                         'type' => 'include_once',
                         'startline' => $this->includeLine,
                         'endline' => $this->yyLex->line,
                         'documentation' => $this->includeComment);
        if ($this->_options['includeContainer']) {
            $container = $this->_options['includeContainer'];
            $include = new $container;
            $include->setParsedData($inc);
        } else {
            $include = $inc;
        }
        $this->includes[] = $include;
        // publish the newly parsed include, if includes should be published
        if ($this->_options['publisher'] && $this->_options['publishIncludes']) {
            $publish = $this->_options['publishMethod'];
            $message = 'include';
            if ($this->_options['publishIncludeMessage']) {
                $message = $this->_options['publishIncludeMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $include);
        }
        $$ = $this->yW[$yyTop - 1] . $3;
    }
    |    T_EVAL '(' expr ')'
    {
        $$ = $this->yW[$yyTop - 3] . $this->yW[$yyTop - 2] . $3 . $this->yW[$yyTop];
    }
    |
    {
        $this->includeLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->includeComment = $lc[0];
    } T_REQUIRE expr            
    {
        $inc = array('file' => trim($3),
                         'type' => 'require',
                         'startline' => $this->includeLine,
                         'endline' => $this->yyLex->line,
                         'documentation' => $this->includeComment);
        if ($this->_options['includeContainer']) {
            $container = $this->_options['includeContainer'];
            $include = new $container;
            $include->setParsedData($inc);
        } else {
            $include = $inc;
        }
        $this->includes[] = $include;
        // publish the newly parsed include, if includes should be published
        if ($this->_options['publisher'] && $this->_options['publishIncludes']) {
            $publish = $this->_options['publishMethod'];
            $message = 'include';
            if ($this->_options['publishIncludeMessage']) {
                $message = $this->_options['publishIncludeMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $include);
        }
        $$ = $this->yW[$yyTop - 1] . $3;
    }
    |
    {
        $this->includeLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->includeComment = $lc[0];
    } T_REQUIRE_ONCE expr        
    {
        $inc = array('file' => trim($3),
                         'type' => 'require_once',
                         'startline' => $this->includeLine,
                         'endline' => $this->yyLex->line,
                         'documentation' => $this->includeComment);
        if ($this->_options['includeContainer']) {
            $container = $this->_options['includeContainer'];
            $include = new $container;
            $include->setParsedData($inc);
        } else {
            $include = $inc;
        }
        $this->includes[] = $include;
        // publish the newly parsed include, if includes should be published
        if ($this->_options['publisher'] && $this->_options['publishIncludes']) {
            $publish = $this->_options['publishMethod'];
            $message = 'include';
            if ($this->_options['publishIncludeMessage']) {
                $message = $this->_options['publishIncludeMessage'];
            }
            $publisher = $this->_options['publisher'];
            $publisher->$publish($message, $include);
        }
        $$ = $this->yW[$yyTop - 1] . $3;
    }
;

isset_variables:
        variable                 
    |    isset_variables ','  variable 
    {
        $$ = $1 . $this->yW[$yyTop - 1] . $3;
    }
;    

class_constant:
        fully_qualified_class_name T_PAAMAYIM_NEKUDOTAYIM T_STRING
        {
            $$ = $1 . $this->yW[$yyTop - 1] . $this->yW[$yyTop];
            $this->_lastConst = $3;
            $this->_lastClassname = trim($1);
        }
;

%%
}
